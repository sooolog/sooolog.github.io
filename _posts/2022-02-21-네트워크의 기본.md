<p align="center">
<img src="">
</p>

# 📖 

* 3-way handshake와 4-way handshake에 대하여
* 

> 모든 코드는 [깃헙](https://github.com/sooolog/dev-spring-springboot)에 작성되어 있습니다.
* * *

<br>



### 1.네트워크 통신 3 way handshake, 4 way handshake에 대해 알아보자.

<p align="center">
<img src="https://user-images.githubusercontent.com/59492312/154784990-1d04c43b-662c-4b21-9b0e-f58d3881d8f9.png">
</p>

우리가 개발할 때 사용하는 네트워크 통신에 대해 들어가기게 앞서 알아두어야 할 기본 지식들이 있다.

TCP는 한번씩 들어봤을거다. (Transmission Control Protocol)로 쉽게 말하자면 인터넷상에서 데이터를 
메세지의 형태로 보내기 위해 IP와 함께 사용하는 규약이다. 브라우저에서 클라이언트가 우리가 배포한 서버로 접근하는것도,
리버스 프록시인 엔진엑스에서 WAS로 보내는 네트워크 통신도 TCP 통신의 일종이다.
               
<br>

> **HTTP통신과 TCP통신은 다른게 아닌가요?**         
> Http통신도 TCP통신을 기반으로 만들어져 있다. 그렇기에 아래에 설명할 3-way handshake, 4-way handshake 과정을
> TCP통신 뿐만이 아니라, Http통신도 똑같이 적용이된다. 아래에 3-way handshake와 4-way handshake를 보고나면 이해가 더 
> 잘 될것이다.    
> [HTTP통신과 TCP통신](https://hwan-shell.tistory.com/271)
                                                          
<br>

> [TCP란 무엇인가](https://mangkyu.tistory.com/15)

<br>

<p align="center">
<img src="https://user-images.githubusercontent.com/59492312/154784783-bb6a0a2f-adfc-435d-a479-627d43f795f7.png">
</p>

그럼 TCP 통신에 대해 알았으니, 그 과정에 대해 보도록 하겠다. 클라이언트와 서버단에서 서로 TCP 통신을
하기 위해서는 여러 과정을 거친다. 우선 클라이언트단에서 서버단에 최초의 연결을 맺으려 할 때 **3-way handshake**라는
과정을 거치게 된다.

**3-way handshake**란,    
1.클라이언트는 서버로 통신을 시작하겠다는 SYN을 보내고,       
2.서버는 그에 대한 응답으로 SYN+ACK를 보낸다.    
3.마지막으로 클라이언트는 서버로부터 받은 패킷에 대한 응답으로 ACK를 보낸다.   
이렇게 3-way-handshake를 정상적으로 마친 다음 클라이언트는 서버에 데이터를 요청한다.

3-Way Handshake를 하는 이유는 클라이언트, 서버 모두 데이터를 전송할 준비가 
되었다는 것을 보장하기 위한 것이다.

<br>

> [3-way handshake에 관하여 (1)](https://ohcodingdiary.tistory.com/7)     
> [3-way handshake에 관하여 (2)](https://puzzle-puzzle.tistory.com/entry/TIMEWAIT-%EC%86%8C%EC%BC%93%EC%9D%B4-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5)

<br>

<p align="center">
<img src="https://user-images.githubusercontent.com/59492312/154784775-0da1bd23-d1c3-4e51-9b2c-b982ea204789.png">
</p>

그 다음, 데이터를 주고 받은 뒤에 해당 연결을 끊어야 하는데 이 또한 4가지 과정을 거쳥 한다.
이를 4-way handshake라 한다. 아래 순서를 보겠다.

**4-way handshake란**    
1.클라이언트는 응답을 주고 연결을 끊기 위해 FIN패킷을 보낸다.     
2.서버는 클라이언트에서 보낸 패킷에 대한 응답으로 ACK 패킷을 보낸다.     
3.서버는 자신이 사용한 소켓을 정리하며 통신을 완전히 끝내도 된다는 의미로 FIN 패킷을 보낸다.    
4.클라이언트는 서버 패킷에 대한 응답으로 ACK패킷을 보낸다.    

4-way handshake과정을 거치고 나면 클라이언트와 서버단의 네트워크는 종료가 된다.

<br>

> 연결을 맺을 때는 연결을 맺고자 하는 쪽에서 먼저 SYN를 보내며, 
> 연결을 끊을 때는 연결을 끊으려는 쪽에서 먼저 FIN을 보낸다.

<br>

> [4-way handshake에 관하여](https://puzzle-puzzle.tistory.com/entry/TIMEWAIT-%EC%86%8C%EC%BC%93%EC%9D%B4-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5)

<br>

<p align="center">
<img src="https://user-images.githubusercontent.com/59492312/154785710-fbedc126-d668-4b2c-b898-fbd442514f43.png">
</p>

위에서 본 TCP 통신은 모두 TCP Socket 통신이다. TCP Socket 통신은 소켓(socket)을 이용하여
클라이언트단과 서버단이 각각 소켓에 명시된 자신의 포트를 통해 통신해야만 한다. 즉, 클라이언트과 서버가 연결을 할 때도 
데이터를 교환할 때도 해당 소켓의 포트를 이용해야한다. 

즉, 3-way handshake, 4-way handshake 모두 클라이언트단과 서버단에 소켓(socket)이
생성되어야만 이 소켓을 연결부로 사용하여 통신을 할 수 있게 되는것이다.

<br>

> 소켓(Socket)은 프로토콜, IP주소, 포트로 정의되며, 네트워크상에서 동작하는 프로그램 간 통신의 종착점(Endpoint)이다.
> (정확히는 엔드포인트의 연결부이다.) 즉, 데이터를 통신할 수 있도록 해주는 연결부이기 때문에 통신할 두 프로그램(Client, Server) 
> 모두에 소켓이 생성되야 한다.      
> [소켓(socket)이란 (1)](https://medium.com/@su_bak/term-socket%EC%9D%B4%EB%9E%80-7ca7963617ff)
> [소켓(socket)이란 (2)](https://helloworld-88.tistory.com/215)

<br>

> Endpoint : IP Address와 port 번호의 조합을 뜻하며 최종 목적지를 나타낸다. 
> 예시로 최종목적지는 사용자의 디바이스(PC, 스마트폰 등) 또는 Server가 될 수 있다.    
> [엔드포인트(Endpoint)란](https://medium.com/@su_bak/term-socket%EC%9D%B4%EB%9E%80-7ca7963617ff)

<br>

<p align="center">
<img src="https://user-images.githubusercontent.com/59492312/154796824-93793128-9ae0-414b-8529-c8f6bd8c48e7.png">
</p>

그렇다면, 4-way handshake에 대해 더 자세히보고 4-way handshake를 사용하는 이유를 보도록 하겠다. 
위의 과정에서 왼쪽이 A, 오른쪽이 B라하면 A에서 먼저 연결을 끊는것으로 볼 수 있다.
(A가 FIN을 B로 보내고 있으니) 그 이후 마지막으로 A가 ACK를 B로 보내고
time_wait상태로 빠진다. B는 A에게서 마지막 ACK를 받고 소켓을 종료시킨다.
하지만, A는 time_wait로 인해 일정시간이 지나고 나서야 소켓이 닫힌다.

여기서, A가 time_wait시간을 갖는 이유는, 만약 B가 마지막 ACK를 받지못하면 
위에서 보이는 바와같이 B가 A에게 다시한번 FIN(위의 그림에서 위에서 세번째 화살표)을
보내게된다. 그런데, 만약 A가 time_wait없이 종료된 상태면 B가 원활한 종료를 하지 못하는것이다.
그렇기에, 마지막 A가 B에게 ACK를 보낼때 A는 time_wait상태에 빠지고, B는 해당 ACK를 받으면
정상적으로 소켓이 닫히고, A 소켓은 정해진 time 후에 자동으로 닫힌다.

<br>

> centos ~에서 time_wait 시간은    
> []()

<br>

> 위의 그림에서는 계속해서 클라이언트단이 연결을 먼저 끊어서 FIN을 서버단에 보낸다고 나와있는데,
> 클라이언트뿐만 아니라 서버단에서도 먼저 끊을 수 있다. 즉, 클라이언트라해서 꼭 연결을 먼저 끊는것은 아니며
> 서버단이라고 연결이 끊어질 때 FIN 먼저 받기만하지 않는다. 반대로도 일어날 수 있는거다. 서버단에서 먼저 연결을 끊으면
> 서버단에서 먼저 FIN을 클라이언트단으로 보내고 위와같은 과정이 똑같이 일어나지만 서버단과 클라이언트단의 역활만 바뀔 뿐이다.
> 그렇기에, 연결을 먼저 끊는 쪽을 active closer라하고 그 반대를 passive closer라 한다. 클라이언트,서버 둘다 active closer
> passive closer가 될 수 있는거다.     
> [active closer와 passive closer에 대하여](https://puzzle-puzzle.tistory.com/entry/TIMEWAIT-%EC%86%8C%EC%BC%93%EC%9D%B4-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%97%90-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5)

<br>

> [active closer와 passive closer의 소켓 반환 시기 (1)](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=cache798&logNo=130039539454)
> [active closer와 passive closer의 소켓 반환 시기 (2)](https://velog.io/@sparkbosing/Network-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%98-%EC%9B%90%EB%A6%AC7)
> [4-way handshake와 time_wait 소켓 (1)](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=cache798&logNo=130039539454)
> [4-way handshake와 time_wait 소켓 (2)](https://tech.kakao.com/2016/04/21/closewait-timewait/)

<br>



### 2.time-wait 소켓 발생에 대하여

<p align="center">
<img src="https://user-images.githubusercontent.com/59492312/154788409-5bb4fd57-b393-4b59-b8d0-37ad4783ab36.png">
</p>

어느쪽이든 Client 입장 (요청하는 쪽)에선 요청을 보내기 위해 커널에서 할당 받은 로컬 포트로 소켓 생성을 요청한다.

여기에다, 포트가 고유해야한다는것도 적기, 커널에 대한것도 간단히

<br>

> 여기서 어느쪽이든 이라는 말의 의미는 3-way handshake나 4-way handshake모두 클라이언트와 서버단이
> 구분되어져 있다. 하지만, 꼭, EC2인스턴스가 서버단이 되고 유저들이 클라이언트단이 되는것은 아니다. 먼저 요청을
> 보내는 쪽이 

<br>

<p align="center">
<img src="https://user-images.githubusercontent.com/59492312/154785753-a888d786-323e-4d05-9cf6-6b05ebef724d.png">
</p>

a

<br>

<p align="center">
<img src="https://user-images.githubusercontent.com/59492312/154785710-fbedc126-d668-4b2c-b898-fbd442514f43.png">
</p>

a

<br>

<p align="center">
<img src="">
</p>

a

#### 🪁 References
* 참조링크 : []()
* 참조링크 : []()

<br>



### 🚀 추가로,

<p align="center">
<img src="https://user-images.githubusercontent.com/59492312/154786799-3d5a6320-20db-4062-be1f-4571df1a84a8.png">
</p>

앞서,HTTP통신이 TCP통신기반이라 얘기했었다. 하지만, HTTP통신과 TCP통신의 차이점도 분명히 존재한다.

**Http통신**  
1. 클라이언트가 요청을 보내는 경우에만 Server가 응답하는 단방향 통신이다.
2. Server로 부터 응답을 받은 후에는 연결이 바로 종료된다.
3. 요청을 보내 server의 응답을 기다리는 어플리케이션의 개발에 주로 사용된다.

**TCP 소켓통신**
1. Server와 Client가 계속 연결을 유지하는 양방향 통신이다.
2. Server와 Client가 실시간으로 데이터를 주고받는 상황이 필요한 경우에 사용된다.
3. 실시간 동영상 Streaming이나 온라인 게임등에 자주 사용된다.

<br>

> 만약, 웹서비스에서 리버스 프록시인 Nginx와 로드벨런서를 사용하는 경우, 브라우저 클라이언트단에서
> 요청을 보낼때는 Http통신을 하고, Nginx에서 이를 받아 WAS로 보낼때는 TCP 소켓(socket)통신을
> 하게 된다.(또한, WAS와 외부api통신, WAS와 RDS통신 모두 소켓통신이다.)

<br>

#### 🪁 References
* 참조링크 : [http통신과 TCP 소켓통신 (1)](https://hwan-shell.tistory.com/271)    
* 참조링크 : [http통신과 TCP 소켓통신 (2)](https://helloworld-88.tistory.com/215)

<br>



태그 : #포트, #소켓, #3-way handshake, #4-way handshake, #time_wait, #HTTP통신, #TCP통신, #TCP 소켓통신
